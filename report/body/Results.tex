\chapter{Results and Discussions}

The results of the experiments performed on the NPSC modules are given and described in this section. Results belonging to the same category are firstly described and a discussion on the outcome of the experiment is done on each result and on the category to see whether or not the results converge. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION: Hardware module tests
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hardware module tests}
This section provides the result of the hardware serial communication protocol. Each result is compared to the theoretical communication protocol of its corresponding hardware module. 

\subsection{DS1307}
The external RTC (DS1307) was tested by writing the value of 5 to its minute memory register. The serial information generated by the I2C pins are displayed in \cref{coms_ds1307}. The clock serial information is observed at channel 0 and the data serial information is observed at channel 1. The logic analyser was set to analyse the data using the I2C protocol, the interpretation of the data is displayed above the SDA serial data.
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{coms_ds1307.png}
	\caption{Serial information sent to the external RTC when setting the minute to 5.}
	\label{coms_ds1307}
\end{figure}
\subsubsection{Discussion}
The I2C protocol is started when the SDA changes state going from high to low while the SCL line is high, this is indicated by the green dot on SDA line. The address of the DS1307 is then sent with an extra 0 bit indicating that a write action is required ($Write['208']$)). The address of the minute registered is then sent ($'1'$) and finally, the data is written to the register ($'5'$). Note that each instruction sent is acknowledged ($+ACK$) by the DS1307.

\subsection{25LC640}
The EEPROM (25LC640) was tested by writing a value of 10 at its first address. The serial information generated by the 25LC640 pins are displayed in \cref{fig:coms_25lc640}. The MOSI, MISO, CLK, and EN serial information are respectively observed at channel 0,1,2, and 3. The logic analyser was set to analyse the data using the SPI protocol, the interpretation of the data is displayed above the MOSI and MISO serial data.
\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.6]{coms_25lc640_start.png}
		\subcaption[first caption.]{Start of serial communication between the STM and the eeprom after when writing to the eeprom.}
		\label{fig:coms_25lc640_start}
	\end{minipage}
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.6]{coms_25lc640_data.png}
		\subcaption[second caption.]{End of serial communication between the STM and the EEPROM after when writing to the EEPROM.}
		\label{fig:coms_25lc640_data}
	\end{minipage}    
	\caption{Serial communication between the STM and the EEPROM after when writing to the EEPROM.}
	\label{fig:coms_25lc640}
\end{figure}
\subsubsection{Discussion}
Each group of instructions is sent when the enable (EN) line is pulled low and end when it is pulled high. The communication starts with a reset of the 25LC640 write enable latch as shown in  \cref{fig:coms_25lc640_start}. This operation consists of writing the \textit{WRDI (6)} instruction to the EEPROM. Following this is the write instruction and the data to be written sent on the MOSI line (\cref{fig:coms_25lc640_data}). Note that when data is being written to the device, only the MOSI line is active and the MISO line is in an impedance state observed as a logic 1 by the serial analyser. 

\subsection{HC-06}
The Bluetooth (HC-06) was tested by sending the string "abcdefg" to the Bluetooth device. The serial information generated by the STM Tx and Rx pins are displayed in \cref{fig:coms_hc-06}. As the Bluetooth device is receiving data, only the STM Tx line is displaying useful data. The analyser was set to interpret the UART protocol. The interpretation is display on the Tx line. 
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{coms_hc-06.png}
	\caption{Serial information received by the bluetooth device.}
	\label{fig:coms_hc-06}
\end{figure}
\subsubsection{Discussion}
The UART protocol is asynchronous and therefore does not use a clock; the data is sent continously as a stream of bits analysed in group of 8 to represent a character. The data sent matches what was expected. 

\subsection{NX4024T032\_001}
The nextion (NX4024T032\_001) was tested by sending the string "nextion" to the nextion device. The serial information generated by the STM Tx and Rx pins are displayed in \cref{fig:coms_nextion}. As the Bluetooth device is receiving data, only the STM Tx line is displaying useful data. The analyser was set to interpret the UART protocol. The interpretation is display on the Tx line. 
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{coms_nextion.png}
	\caption{Serial information received by the nextion device.}
	\label{fig:coms_nextion}
\end{figure}
\subsubsection{Discussion}
The nextion touchscreen and the bluetooth device use the exact same protocol. The stream of data sent is correct. 

\subsection{WS2812}
The neopixels (WS2812) were tested by analysing the data sent by the STM. \Cref{fig:coms_ws2812_data} displays the encoded bit based on the Non-Return to Zero (NRZ) encoding used by the neopixels. \Cref{fig:coms_ws2812_low} displays 0 in NRZ while \cref{fig:coms_ws2812_high} displays 1 using the NRZ encoding. The timing information of the pulse generated by the STM are displayed on both figures.\\
To verify that the right information is sent to the neopixels, a stream of 24 PWM pulses, 8 per colour was sent to the neopixel in order to program the first pixel. The result of these tests are displayed in \ref{fig:coms_ws2812_colour}
\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.8]{coms_ws2812_low.png}
		\subcaption[first caption.]{Representation of 0 using the neopixel NRZ encoding.}
		\label{fig:coms_ws2812_low}
	\end{minipage}
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.8]{coms_ws2812_high.png}
		\subcaption[second caption.]{Representation of 1 using the neopixel NRZ encoding.}
		\label{fig:coms_ws2812_high}
	\end{minipage}    
	\caption{Data sent to one neopixel to turn on specific colours.}
	\label{fig:coms_ws2812_data}
\end{figure}
\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.8]{coms_ws2812_red.png}
		\subcaption[first caption.]{Data sent to one pixel to turn on its red led.}
		\label{fig:coms_ws2812_red}
	\end{minipage}
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.8]{coms_ws2812_green.png}
		\subcaption[second caption.]{Data sent to one pixel to turn on its green led.}
		\label{fig:coms_ws2812_green}
	\end{minipage}
	\begin{minipage}[b]{\textwidth}
		\centering
		\includegraphics[scale=0.8]{coms_ws2812_blue.png}
		\subcaption[second caption.]{Data sent to one pixel to turn on its blue led.}
		\label{fig:coms_ws2812_blue}
	\end{minipage}    
	\caption{Data sent to one neopixel to turn on specific colours.}
	\label{fig:coms_ws2812_colour}
\end{figure}

\subsubsection{Discussion}
According to the WS2812 datasheet (see the documentation in \ref{npsc_harware}), the period of each code must be $ 1.25\mu s \pm 600ns$, looking at the codes in \ref{fig:coms_ws2812_data}, the STM achieves exactly a period of $1.25\mu s$. The datasheet specifies that the high time of code 1 should be $0.4\mu s \pm 0.15 \mu s$, the STM achieves a time of $0.42 \mu s$ which is in the range of the requirement. The high time of code 1 as per the datasheet should be $0.85 \mu s \pm 0.15 \mu s$, the time achieved is $0.833 \mu s$ which is also in the range of the required time. The codes generated by the STM to control the neopixels are in the right format.\\
Each neopixel requires a stream of 24 codes to be programmed. The first, second and third group of 8 codes represent respectively the 8bit value of the neopixel's green, red, and blue led. \Cref{fig:coms_ws2812_red}, \cref{fig:coms_ws2812_green}, and \cref{fig:coms_ws2812_blue} display the stream of 24 code setting the neopixel to red, green, and blue respectively. In \cref{fig:coms_ws2812_red}, it is expected to have code 0 for the first and last 8 pulses (green and blue) and code 1 for the second 8 pulses (red). The STM can send the correct stream to program the neopixels.

\subsection{Final comments on the hardware tests}
All tests performed on the hardware were successful, this is an indication that all modules work perfectly independently of any other modules. This is the basis for the test to be performed at a higher level of the hierarchy. However, some of the tests performed on the hardware are only focused on the STM sending the correct information to the device. Although this is a requirement for the communication to be established, the information received by the STM from the device should also be tested thoroughly. Moreover, these tests do not take into account other modules such as the sensors which use the STM analogue to digital converter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION: Software tests
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Software Tests}
The results of all software tests performed on the NPSC are given in this section. It starts with the analysis of the unit tests followed by the result and analysis of the integration test. The last section is dedicated to the results and analysis of further tests and experiments performed in order to find the point of failure of some tests.

\subsection{Unit tests outcome}
The unit tests are sets of logical functions performed on specific hardware modules. After ensuring that the basic hardware tests have been passed, the following tests were run on the hardware framework. The outcome of the units tests run on the hardware and the coverage of the tests are given in \cref{table:software_unit_test}.
\begin{table}[h!]
	\centering
	\caption{Unit test outcome.}
	\label{table:software_unit_test}
	\begin{tabular}{cccc}
		\hline
		\hline
		\toprule
		\textbf{Hardware} & \textbf{Unit test} & \textbf{Outcome} & \textbf{Coverage}\\
		\bottomrule
		\toprule
		\multirow{3}{*}{internal RTC} & test\_clock\_date & Pass & \multirow{3}{*}{33.33\%}\\
		& test\_clock\_time & Pass &\\
		& test\_clock\_alarm & Pass &\\
		\midrule
		external RTC & test\_rtc\_clock & Pass & 47.1\%\\
		\midrule
		\multirow{3}{*}{queue} & test\_queue\_create & Pass & \multirow{3}{*}{44.44\%}\\
		& test\_queue\_enqueue & Pass &\\
		& test\_queue\_dequeue & Pass &\\
		\midrule
		\multirow{3}{*}{eeprom} & test\_eeprom\_write\_read & Pass & \multirow{3}{*}{66.67\%}\\
		& test\_eeprom\_write4B\_read4B & Pass &\\
		& test\_eeprom\_writeNB\_readNB & Pass &\\
		\bottomrule
		\hline
		\hline
	\end{tabular}
\end{table}
\subsubsection{Discussion}
All unit tests designed for the hardware have passed. This is an indication of the functioning of these hardware module at a logic level. This level is above the simple communication protocol verification between hardware. At this level, the logical operations performed on the hardware are perfomed. Note that the logic level hardware test require a positive outcome of the hardware communication tests.The coverage of the test is neither a line or statement coverage but a function coverage. For each test, the coverage is the ratio of the number of functions called by the module over the number of functions in the module as a percentage. A 33.33\% coverage indicates that only a third of the function in the module have been called. Therefore a low coverage is not an indication that the test did not cover all used functions of the module in the system.   

\subsection{Integration tests outcome}
The integration tests are designed to verify the functionalities of the applications. Unlike the unit tests, they are not specific to one framework but to one application. Each test is designed to suit the application are the logic of each application is different and complexed. The outcome and the coverage of the application test are given in \cref{table:software_integration_test}.
\begin{table}[h!]
	\centering
	\caption{Integration test outcome.}
	\label{table:software_integration_test}
	\begin{tabular}{cp{20em}cc}
		\hline
		\hline
		\toprule
		\textbf{Application} & \textbf{Test} & \textbf{Outcome} & \textbf{Coverage}\\
		\bottomrule
		\toprule
		\multirow{6}{*}{alarm} & test\_alarm\_address & Pass & \multirow{2}{*}{66.67\%}\\
		& test\_alarm\_save\_load & Pass &\\ 
		& Alarm to be triggered at a desired time and date & \multirow{2}{*}{Pass} & \multirow{2}{*}{N/A}\\ 
		& Alarm is loaded from EEPROM to either alarm A or B & \multirow{2}{*}{Pass} & \multirow{2}{*}{N/A}\\ 
		\midrule
		instruction & instruction\_execute & Pass & 100\%\\
		\midrule
		\multirow{3}{*}{visual} & Analyse neopixels data when all module are connected and compared to it to the expected data & \multirow{3}{*}{Fail} & \multirow{3}{*}{N/A}\\
		\bottomrule
		\hline
		\hline
	\end{tabular}
\end{table}
\subsubsection{Alarm}
The first test verifies that the address of each datatype of the AlarmTypeDef \footnote{Type definition of an alarm containing a label, a ringtone, a pattern, a time, a date, \ldots} used to store the alarm is correct. The second test verify that an alarm has been successfully saved in the EEPROM. Those two tests which covers 66.67\% of the code indicate that the interaction between the alarm application and the EEPROM is correct. Two other tests were performed on the application to ensure that the alarm type definition are actually set as alarm in either alarm A or B and are triggered accordingly. These two test are not automatic and therefore a their coverage cannot be given. These test have shown that the alarm application works perfectly.
  
\subsubsection{Instruction}
The instruction application test is similar to the hardware communication test. All functions in this application were tested under the \textit{instrcution\_execute} fucntions as it calls all other functions. The first set of instructions sent to the nextion screen after a clock request are displayed in \cref{fig:coms_instruction_nextion}.
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{coms_instruction_nextion.png}
	\caption{instruction sent to the nextion touchscreen to update the clock displayed on the screen.}
	\label{fig:coms_instruction_nextion}
\end{figure}
As explained in \ref{IFDE}, the STM communicate with the nextion touchscreen using a process consisting of three phases. The first phase (instruction\_nextionStart) consists of sending \textit{code\_c\"{y}\"{y}\"{y}} as seen in \cref{fig:coms_instruction_nextion}. The following information sent are instructions from the second phase of communication. The instruction application is working according to its design.

\subsubsection{Visual}
The visual application which relies mainly on the neopixels hardware failed. After performing the tests explained in \ref{visual_fail}, two main design consideration were found to be the cause of the problem. Firstly using different power supply for the Ring module disturbs the data obtained by the neopixel even if both power supply have the same ground line. Secondly, when all module are activated, their interrupt service routines (ISRs) pause the stream of data sent to the neopixels. The stream cannont be paused as it will be interpreted by the neopixels as two different streams. 
 
\subsection{Insight on Visual module integration failure}\label{visual_fail}
\subsubsection{Different power line}
\subsubsection{Interrupt Service Routines}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION: Ring 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ring experiments}

\subsection{Current drawn by the Ring}
\subsubsection{Experimental results}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{current_one_pixel.pdf}
	\caption{}
	\label{fig:current_one_pixel}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{current_idle.pdf}
	\caption{}
	\label{fig:current_idle}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{current_180_neopixels.pdf}
	\caption{}
	\label{fig:current_180_neopixels}
\end{figure}

\subsubsection{Discussion}

\subsection{Ring temperature by the Ring}
\subsubsection{Experimental results}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{temperature_ring.pdf}
	\caption{}
	\label{fig:temperature_ring}
\end{figure}

\subsubsection{Discussion}

\subsection{Illuminance produced by the Ring}
\subsubsection{Experimental results}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{illuminance_blue.pdf}
	\caption{}
	\label{fig:illuminance_blue}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{illuminance_distance.pdf}
	\caption{}
	\label{fig:illuminance_distance}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{illuminance_angle.pdf}
	\caption{}
	\label{fig:illuminance_angle}
\end{figure}

\subsubsection{Discussion}